# 2 "ocaml_mode.mll"
 
  open Lexing 
  
  
  type token =
    AMPERAMPER
  | AMPERSAND
  | AND
  | AS
  | ASSERT
  | BAR
  | BARBAR
  | BARRBRACKET
  | BEGIN
  | CHAR
  | CLASS
  | COLON
  | COLONCOLON
  | COLONEQUAL
  | COLONGREATER
  | COMMA
  | CONSTRAINT
  | DO
  | DONE
  | DOT
  | DOTDOT
  | DOWNTO
  | ELSE
  | END
  | EOF of (Text.position)
  | EQUAL
  | EXCEPTION
  | EXTERNAL
  | FALSE
  | FLOAT
  | FOR
  | FUN
  | FUNCTION
  | FUNCTOR
  | GREATER
  | GREATERRBRACE
  | GREATERRBRACKET
  | IF
  | IN
  | INCLUDE
  | INFIXOP0
  | INFIXOP1
  | INFIXOP2
  | INFIXOP3
  | INFIXOP4
  | INHERIT
  | INITIALIZER
  | INT
  | LAZY
  | LBRACE
  | LBRACELESS
  | LBRACKET
  | LBRACKETBAR
  | LBRACKETLESS
  | LESS
  | LESSMINUS
  | LET
  | LIDENT
  | LPAREN
  | MATCH
  | METHOD
  | MINUSGREATER
  | MODULE
  | MUTABLE
  | NEW
  | OBJECT
  | OF
  | OPEN
  | OR
  | PARSER
  | PREFIXOP
  | PRIVATE
  | QUESTION
  | QUOTE
  | RBRACE
  | RBRACKET
  | REC
  | RPAREN
  | SEMI
  | SEMISEMI
  | SHARP
  | SIG
  | STAR
  | STRING
  | STRUCT
  | SUBTRACTIVE
  | THEN
  | TO
  | TRUE
  | TRY
  | TYPE
  | UIDENT
  | UNDERSCORE
  | VAL
  | VIRTUAL
  | WHEN
  | WHILE
  | WITH
  | COMMENT
  | EOL of (Text.position)
  | EOFCOMMENT
  | EOFSTRING
  | ERROR
(* for lexers *)
  | RULE
  | PARSE
(* for JoCaml *)
  | DEF
  | LOC
  
  
  let tokens = [AMPERAMPER,"AMPERAMPER"; AMPERSAND,"AMPERSAND";
      AND,"AND"; AS,"AS"; ASSERT,"ASSERT"; BAR,"BAR"; BARBAR,"BARBAR";
      BARRBRACKET,"BARRBRACKET"; BEGIN,"BEGIN"; CHAR,"CHAR";
      CLASS,"CLASS"; COLON,"COLON"; COLONCOLON,"COLONCOLON";
      COLONEQUAL,"COLONEQUAL"; COLONGREATER,"COLONGREATER";
      COMMA,"COMMA"; CONSTRAINT,"CONSTRAINT"; DO,"DO"; DONE,"DONE";
      DOT,"DOT"; DOTDOT,"DOTDOT"; DOWNTO,"DOWNTO"; ELSE,"ELSE";
      END,"END"; EQUAL,"EQUAL"; EXCEPTION,"EXCEPTION";
      EXTERNAL,"EXTERNAL"; FALSE,"FALSE"; FLOAT,"FLOAT"; FOR,"FOR";
      FUN,"FUN"; FUNCTION,"FUNCTION"; FUNCTOR,"FUNCTOR";
      GREATER,"GREATER"; GREATERRBRACE,"GREATERRBRACE";
      GREATERRBRACKET,"GREATERRBRACKET"; IF,"IF"; IN,"IN";
      INCLUDE,"INCLUDE"; INFIXOP0,"INFIXOP0"; INFIXOP1,"INFIXOP1";
      INFIXOP2,"INFIXOP2"; INFIXOP3,"INFIXOP3"; INFIXOP4,"INFIXOP4";
      INHERIT,"INHERIT"; INITIALIZER,"INITIALIZER"; INT,"INT";
      LAZY,"LAZY"; LBRACE,"LBRACE"; LBRACELESS,"LBRACELESS";
      LBRACKET,"LBRACKET"; LBRACKETBAR,"LBRACKETBAR";
      LBRACKETLESS,"LBRACKETLESS"; LESS,"LESS"; LESSMINUS,"LESSMINUS";
      LET,"LET"; LIDENT,"LIDENT"; LPAREN,"LPAREN"; MATCH,"MATCH";
      METHOD,"METHOD"; MINUSGREATER,"MINUSGREATER"; MODULE,"MODULE";
      MUTABLE,"MUTABLE"; NEW,"NEW"; OBJECT,"OBJECT"; OF,"OF";
      OPEN,"OPEN"; OR,"OR"; PARSER,"PARSER"; PREFIXOP,"PREFIXOP";
      PRIVATE,"PRIVATE"; QUESTION,"QUESTION"; QUOTE,"QUOTE";
      RBRACE,"RBRACE"; RBRACKET,"RBRACKET"; REC,"REC"; RPAREN,"RPAREN";
      SEMI,"SEMI"; SEMISEMI,"SEMISEMI"; SHARP,"SHARP"; SIG,"SIG";
      STAR,"STAR"; STRING,"STRING"; STRUCT,"STRUCT";
      SUBTRACTIVE,"SUBTRACTIVE"; THEN,"THEN"; TO,"TO"; TRUE,"TRUE";
      TRY,"TRY"; TYPE,"TYPE"; UIDENT,"UIDENT"; UNDERSCORE,"UNDERSCORE";
      VAL,"VAL"; VIRTUAL,"VIRTUAL"; WHEN,"WHEN"; WHILE,"WHILE";
      WITH,"WITH"; COMMENT,"COMMENT"; EOFCOMMENT,"EOFCOMMENT";
      EOFSTRING,"EOFSTRING"; ERROR,"ERROR"; RULE,"RULE"; PARSE,"PARSE"]
  
  let token_to_string token =
    List.assoc token tokens
  
  let lexer_start = ref 0
  let position lexbuf =
    let b = lexeme_start lexbuf in
    let e = lexeme_end lexbuf in
    b + !lexer_start, e - b
  
  type lexer_error =
    Illegal_character
  | Unterminated_comment
  | Unterminated_string


(* For nested comments *)
  
  let comment_depth = ref 0

(* The table of keywords *)
  
  let keyword_table =
    let h = Hashtbl.create 149 in
    Utils.hash_add_assoc h [
      "and", AND;
      "as", AS;
      "assert", ASSERT;
      "begin", BEGIN;
      "class", CLASS;
      "constraint", CONSTRAINT;
      "do", DO;
      "done", DONE;
      "downto", DOWNTO;
      "else", ELSE;
      "end", END;
      "exception", EXCEPTION;
      "external", EXTERNAL;
      "false", FALSE;
      "for", FOR;
      "fun", FUN;
      "function", FUNCTION;
      "functor", FUNCTOR;
      "if", IF;
      "in", IN;
      "include", INCLUDE;
      "inherit", INHERIT;
      "initializer", INITIALIZER;
      "lazy", LAZY;
      "let", LET;
      "match", MATCH;
      "method", METHOD;
      "module", MODULE;
      "mutable", MUTABLE;
      "new", NEW;
      "object", OBJECT;
      "of", OF;
      "open", OPEN;
      "or", OR;
      "parser", PARSER;
      "private", PRIVATE;
      "rec", REC;
      "sig", SIG;
      "struct", STRUCT;
      "then", THEN;
      "to", TO;
      "true", TRUE;
      "try", TRY;
      "type", TYPE;
      "val", VAL;
      "virtual", VIRTUAL;
      "when", WHEN;
      "while", WHILE;
      "with", WITH;
      "mod", INFIXOP3;
      "land", INFIXOP3;
      "lor", INFIXOP3;
      "lxor", INFIXOP3;
      "lsl", INFIXOP4;
      "lsr", INFIXOP4;
      "asr", INFIXOP4;
(* for lexers *)
      "rule", RULE;
      "parse", PARSE;
    (* for JoCaml *)
      "loc", LOC;
      "def", DEF;
    ];
    h
  
(* To buffer string literals *)
  
  let initial_string_buffer = String.create 256
  let string_buff = ref initial_string_buffer
  let string_index = ref 0
  
  let reset_string_buffer () =
    string_buff := initial_string_buffer;
    string_index := 0
  
  let store_string_char c =
    if !string_index >= String.length (!string_buff) then begin
        let new_buff = String.create (String.length (!string_buff) * 2) in
        String.blit (!string_buff) 0 new_buff 0 (String.length (!string_buff));
        string_buff := new_buff
      end;
    String.unsafe_set (!string_buff) (!string_index) c;
    incr string_index
  
  let get_stored_string () =
    let s = String.sub (!string_buff) 0 (!string_index) in
    string_buff := initial_string_buffer;
    s

(* To translate escape sequences *)
  
  let char_for_backslash =
    match Sys.os_type with
    | "Unix" | "Win32" ->
        begin function
          | 'n' -> '\010'
          | 'r' -> '\013'
          | 'b' -> '\008'
          | 't' -> '\009'
          | c   -> c
        end
    | "MacOS" ->
        begin function
          | 'n' -> '\013'
          | 'r' -> '\010'
          | 'b' -> '\008'
          | 't' -> '\009'
          | c   -> c
        end
    | x -> failwith "Lexer: unknown system type"
  
  let char_for_decimal_code lexbuf i =
    let c = 100 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
        10 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
        (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in  
    Char.chr(c land 0xFF)

(* To store the position of the beginning of a string or comment *)
  
  let start_pos = ref 0

(* Error report *)
  
  exception Error of int * int * lexer_error
  let report_error = function
      Illegal_character ->
        print_string "Illegal character"
    | Unterminated_comment ->
        print_string "Comment not terminated"
    | Unterminated_string ->
        print_string "String literal not terminated"


# 308 "ocaml_mode.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\198\255\199\255\224\000\003\001\038\001\073\001\108\001\
    \143\001\210\255\178\001\215\001\032\000\218\255\036\000\252\001\
    \031\002\068\000\070\000\083\000\066\002\101\002\235\255\136\002\
    \237\255\171\002\121\000\091\000\095\000\248\255\089\000\190\002\
    \007\003\215\003\167\004\254\255\127\000\087\003\224\000\099\000\
    \113\000\034\004\242\004\131\000\101\000\003\001\097\003\119\005\
    \112\000\247\255\107\003\113\000\246\255\117\003\115\000\245\255\
    \244\255\089\004\041\005\007\000\038\001\001\000\243\255\144\005\
    \185\005\220\005\255\005\231\255\227\255\228\255\229\255\225\255\
    \034\006\219\255\220\255\216\255\213\255\069\006\209\255\211\255\
    \104\006\118\001\247\255\248\255\208\000\253\255\114\000\114\000\
    \255\255\254\255\122\006\118\000\252\255\251\255\127\003\149\000\
    \250\255\137\003\150\000\249\255\255\000\250\255\251\255\135\006\
    \255\255\057\004\253\255\080\001\003\001\009\005\252\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\055\000\053\000\052\000\051\000\050\000\
    \050\000\255\255\043\000\040\000\038\000\255\255\034\000\033\000\
    \031\000\029\000\025\000\023\000\048\000\021\000\255\255\019\000\
    \255\255\014\000\013\000\017\000\016\000\255\255\005\000\005\000\
    \004\000\003\000\002\000\255\255\000\000\255\255\006\000\255\255\
    \255\255\255\255\005\000\005\000\005\000\006\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\012\000\255\255\015\000\
    \054\000\049\000\022\000\255\255\255\255\255\255\255\255\255\255\
    \032\000\255\255\255\255\255\255\255\255\041\000\255\255\255\255\
    \047\000\255\255\255\255\255\255\008\000\255\255\008\000\008\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\005\000\
    \255\255\255\255\255\255\001\000\001\000\255\255\255\255";
  Lexing.lex_default = 
   "\001\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \000\000\255\255\255\255\255\255\048\000\000\000\255\255\255\255\
    \255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\000\000\255\255\255\255\000\000\
    \000\000\255\255\255\255\059\000\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\000\000\000\000\000\000\000\000\000\000\
    \255\255\000\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \255\255\082\000\000\000\000\000\091\000\000\000\255\255\255\255\
    \000\000\000\000\255\255\255\255\000\000\000\000\255\255\255\255\
    \000\000\255\255\255\255\000\000\101\000\000\000\000\000\255\255\
    \000\000\255\255\000\000\255\255\255\255\255\255\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\036\000\035\000\062\000\035\000\035\000\000\000\000\000\
    \000\000\062\000\000\000\000\000\061\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \036\000\008\000\029\000\026\000\006\000\003\000\025\000\028\000\
    \027\000\024\000\023\000\004\000\022\000\020\000\019\000\003\000\
    \031\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\018\000\017\000\016\000\015\000\010\000\021\000\
    \005\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\014\000\075\000\013\000\005\000\034\000\
    \073\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\012\000\011\000\009\000\007\000\071\000\
    \070\000\067\000\058\000\069\000\068\000\056\000\255\255\038\000\
    \036\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\044\000\044\000\044\000\044\000\049\000\
    \052\000\058\000\055\000\089\000\088\000\093\000\037\000\036\000\
    \074\000\043\000\043\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\047\000\096\000\099\000\037\000\000\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\000\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\092\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \002\000\003\000\000\000\000\000\003\000\003\000\003\000\255\255\
    \000\000\000\000\003\000\003\000\108\000\003\000\003\000\003\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\003\000\000\000\003\000\003\000\003\000\003\000\
    \003\000\104\000\000\000\108\000\004\000\037\000\000\000\004\000\
    \004\000\004\000\000\000\000\000\090\000\004\000\004\000\060\000\
    \004\000\004\000\004\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\004\000\003\000\004\000\
    \004\000\004\000\004\000\004\000\000\000\037\000\060\000\005\000\
    \059\000\000\000\005\000\005\000\005\000\000\000\000\000\000\000\
    \005\000\005\000\000\000\005\000\005\000\005\000\000\000\000\000\
    \000\000\108\000\108\000\103\000\003\000\000\000\003\000\255\255\
    \005\000\004\000\005\000\005\000\005\000\005\000\005\000\000\000\
    \000\000\000\000\006\000\000\000\000\000\006\000\006\000\006\000\
    \108\000\000\000\000\000\006\000\006\000\000\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\
    \000\000\004\000\000\000\006\000\005\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\007\000\000\000\000\000\
    \007\000\007\000\007\000\000\000\000\000\000\000\007\000\007\000\
    \085\000\007\000\007\000\007\000\000\000\084\000\087\000\000\000\
    \086\000\000\000\005\000\000\000\005\000\000\000\007\000\006\000\
    \007\000\007\000\007\000\007\000\007\000\000\000\000\000\000\000\
    \007\000\000\000\000\000\007\000\007\000\007\000\000\000\000\000\
    \000\000\007\000\007\000\000\000\007\000\007\000\007\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\006\000\000\000\006\000\
    \000\000\007\000\007\000\007\000\080\000\007\000\007\000\007\000\
    \255\255\000\000\000\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \007\000\000\000\007\000\000\000\006\000\007\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\102\000\
    \000\000\006\000\006\000\000\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\007\000\000\000\007\000\000\000\079\000\
    \006\000\006\000\000\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\000\000\000\000\006\000\000\000\000\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\006\000\
    \000\000\006\000\006\000\006\000\000\000\000\000\006\000\078\000\
    \006\000\000\000\000\000\000\000\076\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \006\000\000\000\000\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\000\000\072\000\006\000\006\000\000\000\
    \000\000\000\000\000\000\077\000\000\000\006\000\000\000\000\000\
    \000\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\004\000\000\000\000\000\004\000\004\000\
    \004\000\000\000\000\000\000\000\004\000\004\000\000\000\004\000\
    \065\000\004\000\000\000\000\000\000\000\000\000\083\000\000\000\
    \006\000\000\000\006\000\000\000\004\000\006\000\004\000\004\000\
    \066\000\004\000\004\000\000\000\000\000\000\000\007\000\000\000\
    \000\000\007\000\007\000\007\000\000\000\000\000\000\000\007\000\
    \007\000\000\000\007\000\007\000\007\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\000\000\006\000\000\000\007\000\
    \004\000\007\000\007\000\007\000\007\000\007\000\000\000\000\000\
    \000\000\003\000\000\000\000\000\003\000\003\000\003\000\000\000\
    \000\000\000\000\064\000\003\000\000\000\003\000\003\000\003\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\
    \004\000\000\000\003\000\007\000\003\000\003\000\003\000\003\000\
    \003\000\000\000\000\000\000\000\006\000\000\000\000\000\006\000\
    \006\000\063\000\000\000\000\000\000\000\006\000\006\000\000\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\007\000\000\000\007\000\000\000\006\000\003\000\006\000\
    \006\000\006\000\006\000\006\000\038\000\000\000\030\000\030\000\
    \030\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \039\000\000\000\000\000\037\000\003\000\000\000\003\000\000\000\
    \000\000\006\000\000\000\000\000\000\000\040\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\041\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \039\000\000\000\000\000\037\000\000\000\000\000\000\000\006\000\
    \000\000\006\000\000\000\000\000\000\000\040\000\032\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\041\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\000\000\000\000\000\000\000\000\032\000\000\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\046\000\000\000\046\000\000\000\000\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\054\000\054\000\054\000\
    \054\000\054\000\054\000\054\000\054\000\054\000\054\000\097\000\
    \097\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\098\000\000\000\000\000\000\000\000\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\000\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\033\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\000\000\000\000\000\000\000\000\033\000\000\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\060\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\060\000\000\000\059\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\000\000\000\000\000\000\000\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\000\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\000\000\000\000\000\000\000\000\033\000\000\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\058\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\058\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\000\000\000\000\000\000\000\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\000\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\051\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\006\000\000\000\000\000\006\000\006\000\006\000\000\000\
    \000\000\000\000\006\000\006\000\000\000\006\000\006\000\006\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\006\000\000\000\006\000\006\000\006\000\006\000\
    \006\000\000\000\000\000\051\000\000\000\000\000\000\000\000\000\
    \000\000\051\000\064\000\000\000\000\000\064\000\064\000\064\000\
    \000\000\000\000\000\000\064\000\064\000\051\000\064\000\064\000\
    \064\000\051\000\000\000\051\000\000\000\000\000\006\000\000\000\
    \000\000\000\000\000\000\064\000\000\000\064\000\064\000\064\000\
    \064\000\064\000\000\000\000\000\000\000\004\000\000\000\000\000\
    \004\000\004\000\004\000\000\000\000\000\000\000\004\000\004\000\
    \000\000\004\000\004\000\004\000\006\000\000\000\006\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\004\000\064\000\
    \004\000\004\000\004\000\004\000\004\000\000\000\000\000\000\000\
    \004\000\000\000\000\000\004\000\004\000\004\000\000\000\000\000\
    \000\000\004\000\004\000\000\000\004\000\004\000\004\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\064\000\000\000\064\000\
    \000\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
    \000\000\000\000\000\000\006\000\000\000\000\000\006\000\006\000\
    \006\000\000\000\000\000\000\000\006\000\006\000\000\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \004\000\000\000\004\000\000\000\006\000\004\000\006\000\006\000\
    \006\000\006\000\006\000\000\000\000\000\000\000\006\000\000\000\
    \000\000\006\000\006\000\006\000\000\000\000\000\000\000\006\000\
    \006\000\000\000\006\000\006\000\006\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\004\000\000\000\004\000\000\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\000\000\000\000\
    \000\000\007\000\000\000\000\000\007\000\007\000\007\000\000\000\
    \000\000\108\000\007\000\007\000\107\000\007\000\007\000\007\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\
    \006\000\095\000\007\000\006\000\007\000\007\000\007\000\007\000\
    \007\000\106\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\094\000\094\000\094\000\000\000\000\000\000\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\006\000\000\000\006\000\000\000\000\000\007\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\095\000\000\000\
    \000\000\000\000\000\000\000\000\095\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\106\000\007\000\000\000\007\000\000\000\
    \095\000\106\000\000\000\000\000\095\000\000\000\095\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\106\000\000\000\000\000\
    \000\000\106\000\000\000\106\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\061\000\000\000\000\000\255\255\255\255\
    \255\255\059\000\255\255\255\255\059\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\012\000\000\000\000\000\000\000\
    \014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\017\000\
    \018\000\019\000\026\000\018\000\018\000\027\000\028\000\030\000\
    \036\000\030\000\030\000\030\000\030\000\030\000\030\000\030\000\
    \030\000\030\000\030\000\039\000\039\000\044\000\044\000\048\000\
    \051\000\026\000\054\000\086\000\087\000\091\000\030\000\036\000\
    \014\000\040\000\040\000\040\000\040\000\040\000\040\000\040\000\
    \040\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\043\000\043\000\043\000\043\000\043\000\
    \043\000\043\000\043\000\028\000\095\000\098\000\030\000\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\084\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\003\000\255\255\255\255\003\000\003\000\003\000\059\000\
    \255\255\255\255\003\000\003\000\108\000\003\000\003\000\003\000\
    \038\000\038\000\038\000\038\000\038\000\038\000\038\000\038\000\
    \038\000\038\000\003\000\255\255\003\000\003\000\003\000\003\000\
    \003\000\100\000\255\255\108\000\004\000\038\000\255\255\004\000\
    \004\000\004\000\255\255\255\255\084\000\004\000\004\000\060\000\
    \004\000\004\000\004\000\045\000\045\000\045\000\045\000\045\000\
    \045\000\045\000\045\000\045\000\045\000\004\000\003\000\004\000\
    \004\000\004\000\004\000\004\000\255\255\038\000\060\000\005\000\
    \060\000\255\255\005\000\005\000\005\000\255\255\255\255\255\255\
    \005\000\005\000\255\255\005\000\005\000\005\000\255\255\255\255\
    \255\255\107\000\107\000\100\000\003\000\255\255\003\000\028\000\
    \005\000\004\000\005\000\005\000\005\000\005\000\005\000\255\255\
    \255\255\255\255\006\000\255\255\255\255\006\000\006\000\006\000\
    \107\000\255\255\255\255\006\000\006\000\255\255\006\000\006\000\
    \006\000\255\255\255\255\255\255\255\255\255\255\255\255\004\000\
    \255\255\004\000\255\255\006\000\005\000\006\000\006\000\006\000\
    \006\000\006\000\255\255\255\255\255\255\007\000\255\255\255\255\
    \007\000\007\000\007\000\255\255\255\255\255\255\007\000\007\000\
    \081\000\007\000\007\000\007\000\255\255\081\000\081\000\255\255\
    \081\000\255\255\005\000\255\255\005\000\255\255\007\000\006\000\
    \007\000\007\000\007\000\007\000\007\000\255\255\255\255\255\255\
    \008\000\255\255\255\255\008\000\008\000\008\000\255\255\255\255\
    \255\255\008\000\008\000\255\255\008\000\008\000\008\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\006\000\255\255\006\000\
    \255\255\008\000\007\000\008\000\008\000\008\000\008\000\008\000\
    \084\000\255\255\255\255\010\000\255\255\255\255\010\000\010\000\
    \010\000\255\255\255\255\255\255\010\000\010\000\255\255\010\000\
    \010\000\010\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \007\000\255\255\007\000\255\255\010\000\008\000\010\000\010\000\
    \010\000\010\000\010\000\255\255\255\255\255\255\255\255\255\255\
    \011\000\255\255\255\255\011\000\011\000\011\000\255\255\100\000\
    \255\255\011\000\011\000\255\255\011\000\011\000\011\000\255\255\
    \255\255\255\255\255\255\008\000\255\255\008\000\255\255\010\000\
    \010\000\011\000\255\255\011\000\011\000\011\000\011\000\011\000\
    \255\255\255\255\255\255\255\255\255\255\015\000\255\255\255\255\
    \015\000\015\000\015\000\255\255\255\255\255\255\015\000\015\000\
    \255\255\015\000\015\000\015\000\255\255\255\255\010\000\010\000\
    \010\000\255\255\255\255\255\255\011\000\011\000\015\000\255\255\
    \015\000\015\000\015\000\015\000\015\000\255\255\255\255\255\255\
    \016\000\255\255\255\255\016\000\016\000\016\000\255\255\255\255\
    \255\255\016\000\016\000\255\255\016\000\016\000\016\000\255\255\
    \255\255\255\255\255\255\011\000\255\255\011\000\255\255\255\255\
    \255\255\016\000\015\000\016\000\016\000\016\000\016\000\016\000\
    \255\255\255\255\255\255\020\000\255\255\255\255\020\000\020\000\
    \020\000\255\255\255\255\255\255\020\000\020\000\255\255\020\000\
    \020\000\020\000\255\255\255\255\255\255\255\255\081\000\255\255\
    \015\000\255\255\015\000\255\255\020\000\016\000\020\000\020\000\
    \020\000\020\000\020\000\255\255\255\255\255\255\021\000\255\255\
    \255\255\021\000\021\000\021\000\255\255\255\255\255\255\021\000\
    \021\000\255\255\021\000\021\000\021\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\016\000\255\255\016\000\255\255\021\000\
    \020\000\021\000\021\000\021\000\021\000\021\000\255\255\255\255\
    \255\255\023\000\255\255\255\255\023\000\023\000\023\000\255\255\
    \255\255\255\255\023\000\023\000\255\255\023\000\023\000\023\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\020\000\255\255\
    \020\000\255\255\023\000\021\000\023\000\023\000\023\000\023\000\
    \023\000\255\255\255\255\255\255\025\000\255\255\255\255\025\000\
    \025\000\025\000\255\255\255\255\255\255\025\000\025\000\255\255\
    \025\000\025\000\025\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\021\000\255\255\021\000\255\255\025\000\023\000\025\000\
    \025\000\025\000\025\000\025\000\031\000\255\255\031\000\031\000\
    \031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \031\000\255\255\255\255\031\000\023\000\255\255\023\000\255\255\
    \255\255\025\000\255\255\255\255\255\255\031\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\031\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \031\000\255\255\255\255\031\000\255\255\255\255\255\255\025\000\
    \255\255\025\000\255\255\255\255\255\255\031\000\032\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\031\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\255\255\255\255\255\255\255\255\032\000\255\255\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\037\000\255\255\037\000\255\255\255\255\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\046\000\046\000\046\000\046\000\046\000\046\000\046\000\
    \046\000\046\000\046\000\050\000\050\000\050\000\050\000\050\000\
    \050\000\050\000\050\000\050\000\050\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\094\000\
    \094\000\094\000\094\000\094\000\094\000\094\000\094\000\094\000\
    \094\000\097\000\097\000\097\000\097\000\097\000\097\000\097\000\
    \097\000\097\000\097\000\255\255\255\255\255\255\255\255\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\255\255\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\033\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\255\255\255\255\255\255\255\255\033\000\255\255\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\041\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\041\000\041\000\041\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\057\000\041\000\041\000\041\000\041\000\041\000\
    \041\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\057\000\255\255\057\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\041\000\041\000\041\000\041\000\041\000\
    \041\000\057\000\057\000\057\000\057\000\057\000\057\000\057\000\
    \057\000\057\000\057\000\255\255\255\255\255\255\255\255\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\255\255\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\034\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\255\255\255\255\255\255\255\255\034\000\255\255\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\042\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\042\000\042\000\042\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\058\000\042\000\042\000\042\000\042\000\042\000\
    \042\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\058\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\042\000\042\000\042\000\042\000\042\000\
    \042\000\058\000\058\000\058\000\058\000\058\000\058\000\058\000\
    \058\000\058\000\058\000\255\255\255\255\255\255\255\255\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\255\255\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\047\000\034\000\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\047\000\
    \047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
    \047\000\063\000\255\255\255\255\063\000\063\000\063\000\255\255\
    \255\255\255\255\063\000\063\000\255\255\063\000\063\000\063\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\063\000\255\255\063\000\063\000\063\000\063\000\
    \063\000\255\255\255\255\047\000\255\255\255\255\255\255\255\255\
    \255\255\047\000\064\000\255\255\255\255\064\000\064\000\064\000\
    \255\255\255\255\255\255\064\000\064\000\047\000\064\000\064\000\
    \064\000\047\000\255\255\047\000\255\255\255\255\063\000\255\255\
    \255\255\255\255\255\255\064\000\255\255\064\000\064\000\064\000\
    \064\000\064\000\255\255\255\255\255\255\065\000\255\255\255\255\
    \065\000\065\000\065\000\255\255\255\255\255\255\065\000\065\000\
    \255\255\065\000\065\000\065\000\063\000\255\255\063\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\065\000\064\000\
    \065\000\065\000\065\000\065\000\065\000\255\255\255\255\255\255\
    \066\000\255\255\255\255\066\000\066\000\066\000\255\255\255\255\
    \255\255\066\000\066\000\255\255\066\000\066\000\066\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\064\000\255\255\064\000\
    \255\255\066\000\065\000\066\000\066\000\066\000\066\000\066\000\
    \255\255\255\255\255\255\072\000\255\255\255\255\072\000\072\000\
    \072\000\255\255\255\255\255\255\072\000\072\000\255\255\072\000\
    \072\000\072\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \065\000\255\255\065\000\255\255\072\000\066\000\072\000\072\000\
    \072\000\072\000\072\000\255\255\255\255\255\255\077\000\255\255\
    \255\255\077\000\077\000\077\000\255\255\255\255\255\255\077\000\
    \077\000\255\255\077\000\077\000\077\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\066\000\255\255\066\000\255\255\077\000\
    \072\000\077\000\077\000\077\000\077\000\077\000\255\255\255\255\
    \255\255\080\000\255\255\255\255\080\000\080\000\080\000\255\255\
    \255\255\103\000\080\000\080\000\103\000\080\000\080\000\080\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\072\000\255\255\
    \072\000\090\000\080\000\077\000\080\000\080\000\080\000\080\000\
    \080\000\103\000\090\000\090\000\090\000\090\000\090\000\090\000\
    \090\000\090\000\090\000\090\000\255\255\255\255\255\255\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\077\000\255\255\077\000\255\255\255\255\080\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\090\000\255\255\
    \255\255\255\255\255\255\255\255\090\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\103\000\080\000\255\255\080\000\255\255\
    \090\000\103\000\255\255\255\255\090\000\255\255\090\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\103\000\255\255\255\255\
    \255\255\103\000\255\255\103\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    ";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec token lexbuf =
  __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 325 "ocaml_mode.mll"
    ( token lexbuf )
# 862 "ocaml_mode.ml"

  | 1 ->
# 326 "ocaml_mode.mll"
           ( let (p,_) as pos = position lexbuf in pos, EOL p )
# 867 "ocaml_mode.ml"

  | 2 ->
# 328 "ocaml_mode.mll"
      ( position lexbuf, UNDERSCORE )
# 872 "ocaml_mode.ml"

  | 3 ->
# 330 "ocaml_mode.mll"
    ( position lexbuf,
      let s = Lexing.lexeme lexbuf in
      try
        Hashtbl.find keyword_table s
      with Not_found ->
          LIDENT )
# 882 "ocaml_mode.ml"

  | 4 ->
# 337 "ocaml_mode.mll"
    ( position lexbuf, UIDENT )
# 887 "ocaml_mode.ml"

  | 5 ->
# 339 "ocaml_mode.mll"
      ( position lexbuf, INT )
# 892 "ocaml_mode.ml"

  | 6 ->
# 341 "ocaml_mode.mll"
      ( position lexbuf, FLOAT )
# 897 "ocaml_mode.ml"

  | 7 ->
# 343 "ocaml_mode.mll"
      ( reset_string_buffer();
      let string_start = Lexing.lexeme_start lexbuf in
      start_pos := string_start;
      try
        string lexbuf;
        lexbuf.Lexing.lex_start_pos <-
          string_start - lexbuf.Lexing.lex_abs_pos;
        (!start_pos + !lexer_start, lexeme_end lexbuf - !start_pos), STRING
      with
        Error (pos,len,error) -> (pos,len), EOFSTRING          
    )
# 912 "ocaml_mode.ml"

  | 8 ->
# 355 "ocaml_mode.mll"
      ( position lexbuf, CHAR )
# 917 "ocaml_mode.ml"

  | 9 ->
# 357 "ocaml_mode.mll"
      ( position lexbuf, CHAR )
# 922 "ocaml_mode.ml"

  | 10 ->
# 359 "ocaml_mode.mll"
      ( position lexbuf, CHAR )
# 927 "ocaml_mode.ml"

  | 11 ->
# 361 "ocaml_mode.mll"
      ( comment_depth := 1;
      start_pos := Lexing.lexeme_start lexbuf;
      try
        comment lexbuf;
        (!start_pos + !lexer_start, lexeme_end lexbuf - !start_pos), COMMENT
      with
        Error (pos,len,error) -> (pos,len), EOFCOMMENT
    )
# 939 "ocaml_mode.ml"

  | 12 ->
# 372 "ocaml_mode.mll"
    ( token lexbuf )
# 944 "ocaml_mode.ml"

  | 13 ->
# 373 "ocaml_mode.mll"
         ( position lexbuf, SHARP  )
# 949 "ocaml_mode.ml"

  | 14 ->
# 374 "ocaml_mode.mll"
         ( position lexbuf, AMPERSAND  )
# 954 "ocaml_mode.ml"

  | 15 ->
# 375 "ocaml_mode.mll"
         ( position lexbuf, AMPERAMPER  )
# 959 "ocaml_mode.ml"

  | 16 ->
# 376 "ocaml_mode.mll"
         ( position lexbuf, QUOTE  )
# 964 "ocaml_mode.ml"

  | 17 ->
# 377 "ocaml_mode.mll"
         ( position lexbuf, LPAREN  )
# 969 "ocaml_mode.ml"

  | 18 ->
# 378 "ocaml_mode.mll"
         ( position lexbuf, RPAREN  )
# 974 "ocaml_mode.ml"

  | 19 ->
# 379 "ocaml_mode.mll"
         ( position lexbuf, STAR  )
# 979 "ocaml_mode.ml"

  | 20 ->
# 380 "ocaml_mode.mll"
         ( position lexbuf, COMMA  )
# 984 "ocaml_mode.ml"

  | 21 ->
# 381 "ocaml_mode.mll"
         ( position lexbuf, QUESTION  )
# 989 "ocaml_mode.ml"

  | 22 ->
# 382 "ocaml_mode.mll"
         ( position lexbuf, MINUSGREATER  )
# 994 "ocaml_mode.ml"

  | 23 ->
# 383 "ocaml_mode.mll"
         ( position lexbuf, DOT  )
# 999 "ocaml_mode.ml"

  | 24 ->
# 384 "ocaml_mode.mll"
         ( position lexbuf, DOTDOT  )
# 1004 "ocaml_mode.ml"

  | 25 ->
# 385 "ocaml_mode.mll"
         ( position lexbuf, COLON  )
# 1009 "ocaml_mode.ml"

  | 26 ->
# 386 "ocaml_mode.mll"
         ( position lexbuf, COLONCOLON  )
# 1014 "ocaml_mode.ml"

  | 27 ->
# 387 "ocaml_mode.mll"
         ( position lexbuf, COLONEQUAL  )
# 1019 "ocaml_mode.ml"

  | 28 ->
# 388 "ocaml_mode.mll"
         ( position lexbuf, COLONGREATER  )
# 1024 "ocaml_mode.ml"

  | 29 ->
# 389 "ocaml_mode.mll"
         ( position lexbuf, SEMI  )
# 1029 "ocaml_mode.ml"

  | 30 ->
# 390 "ocaml_mode.mll"
         ( position lexbuf, SEMISEMI  )
# 1034 "ocaml_mode.ml"

  | 31 ->
# 391 "ocaml_mode.mll"
         ( position lexbuf, LESS  )
# 1039 "ocaml_mode.ml"

  | 32 ->
# 392 "ocaml_mode.mll"
         ( position lexbuf, LESSMINUS  )
# 1044 "ocaml_mode.ml"

  | 33 ->
# 393 "ocaml_mode.mll"
         ( position lexbuf, EQUAL  )
# 1049 "ocaml_mode.ml"

  | 34 ->
# 394 "ocaml_mode.mll"
         ( position lexbuf, LBRACKET  )
# 1054 "ocaml_mode.ml"

  | 35 ->
# 395 "ocaml_mode.mll"
         ( position lexbuf, LBRACKETBAR  )
# 1059 "ocaml_mode.ml"

  | 36 ->
# 396 "ocaml_mode.mll"
         ( position lexbuf, LBRACKETLESS  )
# 1064 "ocaml_mode.ml"

  | 37 ->
# 397 "ocaml_mode.mll"
         ( position lexbuf, RBRACKET  )
# 1069 "ocaml_mode.ml"

  | 38 ->
# 398 "ocaml_mode.mll"
         ( position lexbuf, LBRACE  )
# 1074 "ocaml_mode.ml"

  | 39 ->
# 399 "ocaml_mode.mll"
         ( position lexbuf, LBRACELESS  )
# 1079 "ocaml_mode.ml"

  | 40 ->
# 400 "ocaml_mode.mll"
         ( position lexbuf, BAR  )
# 1084 "ocaml_mode.ml"

  | 41 ->
# 401 "ocaml_mode.mll"
         ( position lexbuf, BARBAR  )
# 1089 "ocaml_mode.ml"

  | 42 ->
# 402 "ocaml_mode.mll"
         ( position lexbuf, BARRBRACKET  )
# 1094 "ocaml_mode.ml"

  | 43 ->
# 403 "ocaml_mode.mll"
         ( position lexbuf, GREATER  )
# 1099 "ocaml_mode.ml"

  | 44 ->
# 404 "ocaml_mode.mll"
         ( position lexbuf, GREATERRBRACKET  )
# 1104 "ocaml_mode.ml"

  | 45 ->
# 405 "ocaml_mode.mll"
         ( position lexbuf, RBRACE  )
# 1109 "ocaml_mode.ml"

  | 46 ->
# 406 "ocaml_mode.mll"
         ( position lexbuf, GREATERRBRACE  )
# 1114 "ocaml_mode.ml"

  | 47 ->
# 408 "ocaml_mode.mll"
         ( position lexbuf, INFIXOP0 )
# 1119 "ocaml_mode.ml"

  | 48 ->
# 409 "ocaml_mode.mll"
         ( position lexbuf, SUBTRACTIVE )
# 1124 "ocaml_mode.ml"

  | 49 ->
# 410 "ocaml_mode.mll"
         ( position lexbuf, SUBTRACTIVE )
# 1129 "ocaml_mode.ml"

  | 50 ->
# 413 "ocaml_mode.mll"
    ( position lexbuf, PREFIXOP )
# 1134 "ocaml_mode.ml"

  | 51 ->
# 415 "ocaml_mode.mll"
    ( position lexbuf, INFIXOP0 )
# 1139 "ocaml_mode.ml"

  | 52 ->
# 417 "ocaml_mode.mll"
    ( position lexbuf, INFIXOP1 )
# 1144 "ocaml_mode.ml"

  | 53 ->
# 419 "ocaml_mode.mll"
    ( position lexbuf, INFIXOP2 )
# 1149 "ocaml_mode.ml"

  | 54 ->
# 421 "ocaml_mode.mll"
    ( position lexbuf, INFIXOP4 )
# 1154 "ocaml_mode.ml"

  | 55 ->
# 423 "ocaml_mode.mll"
    ( position lexbuf, INFIXOP3 )
# 1159 "ocaml_mode.ml"

  | 56 ->
# 424 "ocaml_mode.mll"
        ( let (pos,len) = position lexbuf in (pos,len), EOF pos )
# 1164 "ocaml_mode.ml"

  | 57 ->
# 426 "ocaml_mode.mll"
      ( position lexbuf, ERROR )
# 1169 "ocaml_mode.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
  __ocaml_lex_comment_rec lexbuf 81
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 430 "ocaml_mode.mll"
    ( comment_depth := succ !comment_depth; comment lexbuf )
# 1180 "ocaml_mode.ml"

  | 1 ->
# 432 "ocaml_mode.mll"
      ( comment_depth := pred !comment_depth;
      if !comment_depth > 0 then comment lexbuf )
# 1186 "ocaml_mode.ml"

  | 2 ->
# 435 "ocaml_mode.mll"
      ( reset_string_buffer();
      let old_start_pos = !start_pos in
      start_pos := Lexing.lexeme_start lexbuf;
      string lexbuf;
      string_buff := initial_string_buffer;
      start_pos := old_start_pos;
      comment lexbuf )
# 1197 "ocaml_mode.ml"

  | 3 ->
# 443 "ocaml_mode.mll"
      ( comment lexbuf )
# 1202 "ocaml_mode.ml"

  | 4 ->
# 445 "ocaml_mode.mll"
      ( comment lexbuf )
# 1207 "ocaml_mode.ml"

  | 5 ->
# 447 "ocaml_mode.mll"
      ( comment lexbuf )
# 1212 "ocaml_mode.ml"

  | 6 ->
# 449 "ocaml_mode.mll"
      ( comment lexbuf )
# 1217 "ocaml_mode.ml"

  | 7 ->
# 451 "ocaml_mode.mll"
      ( raise
        (Error (!start_pos + !lexer_start, lexeme_end lexbuf - !start_pos,
          Unterminated_comment)) )
# 1224 "ocaml_mode.ml"

  | 8 ->
# 455 "ocaml_mode.mll"
      ( comment lexbuf )
# 1229 "ocaml_mode.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
  __ocaml_lex_string_rec lexbuf 100
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 459 "ocaml_mode.mll"
    ( () )
# 1240 "ocaml_mode.ml"

  | 1 ->
# 461 "ocaml_mode.mll"
    ( string lexbuf )
# 1245 "ocaml_mode.ml"

  | 2 ->
# 463 "ocaml_mode.mll"
      ( store_string_char(char_for_backslash(Lexing.lexeme_char lexbuf 1));
      string lexbuf )
# 1251 "ocaml_mode.ml"

  | 3 ->
# 466 "ocaml_mode.mll"
      ( store_string_char(char_for_decimal_code lexbuf 1);
      string lexbuf )
# 1257 "ocaml_mode.ml"

  | 4 ->
# 469 "ocaml_mode.mll"
      ( raise
        (Error (!start_pos + !lexer_start, lexeme_end lexbuf - !start_pos,
          Unterminated_string)) )
# 1264 "ocaml_mode.ml"

  | 5 ->
# 473 "ocaml_mode.mll"
      ( store_string_char(Lexing.lexeme_char lexbuf 0);
      string lexbuf )
# 1270 "ocaml_mode.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_string_rec lexbuf __ocaml_lex_state

;;

# 476 "ocaml_mode.mll"
 
(* val token : lexbuf -> token *)

(***********************************************************************)
(*                                                                     *)
(*                           xlib for Ocaml                            *)
(*                                                                     *)
(*       Fabrice Le Fessant, projet Para/SOR, INRIA Rocquencourt       *)
(*                                                                     *)
(*  Copyright 1998 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

open Options
open Text
open Efuns
open Interactive
open Simple
open Select
open Compil
open Eval
open Complex
open Abbrevs  
open Keymap
open Window

let lexing text start_point end_point =
  lexer_start := get_position text start_point;
  Text.lexing text start_point end_point

let keyword_color = define_option ["ocaml_mode"; "keyword_color"] ""
    string_option "red"
let string_color = define_option ["ocaml_mode"; "string_color"] ""
    string_option "blue"
let comment_color = define_option ["ocaml_mode"; "comment_color"] ""
    string_option "cadetblue"
let upper_color = define_option ["ocaml_mode"; "upper_color"] ""
    string_option "blue"

let keyword_font = define_option ["ocaml_mode"; "keyword_font"] ""
    string_option !!font
let string_font = define_option ["ocaml_mode"; "string_font"] ""
    string_option !!font
let comment_font = define_option ["ocaml_mode"; "comment_font"] ""
  string_option !!font
let upper_font = define_option ["ocaml_mode"; "upper_font"] ""
  string_option !!font

let ocaml_path = define_option ["ocaml_mode"; "ocaml_path"] ""
    path_option []
  
let _ =
  if !!ocaml_path = [] then
    ocaml_path =:= !!Efuns.load_path
  
(*********************** colors ***********************)
let ocaml_color_region location buf start_point end_point =
  let red_attr = make_attr (get_color location !!keyword_color) 1 
      (get_font location !!keyword_font) false in
  let yellow_attr = make_attr (get_color location !!string_color) 1 
      (get_font location !!string_font)    false in
  let blue_attr = make_attr (get_color location !!comment_color) 1 
      (get_font location !!comment_font) false in
  let gray_attr = make_attr (get_color location !!upper_color) 1 
      (get_font location !!upper_font)     false in
  let text = buf.buf_text in
  let curseur = Text.add_point text in
  let lexbuf = lexing text start_point end_point in
  let rec iter lexbuf =
    let (pos,len), token = token lexbuf in
    (match token with
        EOF _ -> raise Exit
      | LET | IN | MATCH | TRY | WITH | FUN 
      | FUNCTION | IF | THEN | ELSE | WHILE | WHEN
      | DONE | DO | FOR | TO | DOWNTO | BEGIN | END 
      | OPEN | MODULE | STRUCT | MUTABLE
      | AND | OR | TYPE | VAL | CLASS | SIG | INHERIT | OBJECT
      | EXCEPTION | RULE | METHOD | EXTERNAL -> 
          set_position text curseur pos;
          set_attr text curseur len red_attr
      | EOFCOMMENT 
      | COMMENT ->
          set_position text curseur pos;
          set_attr text curseur len blue_attr
      | EOFSTRING
      | CHAR 
      | STRING ->
          set_position text curseur pos;
          set_attr text curseur len yellow_attr
      | UIDENT ->
          set_position text curseur pos;
          set_attr text curseur len gray_attr            
      | _ -> ());
    iter lexbuf
  in
  try
    iter lexbuf
  with
    _ ->
      buf.buf_modified <- buf.buf_modified + 1;
      remove_point text curseur



let ocaml_color_buffer buf =
  let text = buf.buf_text in
  Text.unset_attr text;
  let start_point = Text.add_point text in
  let end_point = Text.add_point text in
  set_position text end_point (size text);
  ocaml_color_region buf.buf_location buf start_point end_point;
  remove_point text start_point;
  remove_point text end_point

let ocaml_color frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let start_point = Text.add_point text in
  let end_point = Text.add_point text in
  set_position text end_point (size text);
  ocaml_color_region buf.buf_location buf start_point end_point;
  remove_point text start_point;
  remove_point text end_point

(************************  abbreviations ********************)

let abbreviations = define_option ["ocaml_mode"; "abbrevs"] ""
    (list_option string2_option) []
  
let _ = 
  if !!abbreviations = [] then
    abbreviations =:=
      [
(* Pervasives *)
      ( "nl'", "print_newline ()");
      ( "pr'i", "print_int");
(* Printexc *)
      ( "to'p","Printexc.to_string");
(* Printf *)
      ( "pr'","Printf.printf");
      ( "spr'", "Printf.sprintf");
      ( "fpr'", "Printf.fprintf");
(* List *)
      ( "rev'l","List.rev");
      ( "ite'l","List.iter");
      ( "len'l","List.length");
      ( "lfol'l","List.fold_left");
      ( "rfol'l","List.fold_right");
      ( "map'l","List.map");
      ( "mem'l","List.mem");
      ( "memq'l","List.memq");
      ( "mass'l","List.mem_assoc");
      ( "assq'l","List.assq");
      ( "spl'l","List.split");
      ( "com'l","List.combine");
(* Array *)
      ( "ite'a","Array.iter");
      ( "len'a","Array.length");
      ( "set'a","Array.set");
      ( "get'a","Array.get");
      ( "cre'a","Array.create");
      ( "ini'a","Array.init");
      ( "cop'a","Array.copy");
      ( "sub'a","Array.sub");
      ( "map'a","Array.map");
      ( "con'a", "Array.concat");
(* Hashtbl *)
      ( "ite'h","Hashtbl.iter");
      ( "fin'h","Hashtbl.find");
      ( "add'h","Hashtbl.add");
      ( "rem'h","Hashtbl.remove");
      ( "cre'h","Hashtbl.create");
      ( "cle'h","Hashtbl.clear");
(* Queue *)
      ( "ite'q","Queue.iter");
      ( "len'q","Queue.length");
      ( "cre'q","Queue.create");
      ( "add'q","Queue.add");
      ( "get'q","Queue.take");
      ( "tak'q","Queue.take");
      ( "cle'q","Queue.clear");
      ( "emp'q","Queue.Empty");
(* Filename *)
      ( "con'f","Filename.concat");
      ( "che'f","Filename.check_suffix");
      ( "cho'f","Filename.chop_suffix");
      ( "bas'f","Filename.basename");
      ( "dir'f","Filename.dirname");
(* String *)
      ( "len's","String.length");
      ( "set's","String.set");
      ( "get's","String.get");
      ( "cre's","String.create");
      ( "mak's","String.make");
      ( "sub's","String.sub");
      ( "cop's","String.copy");
      ( "bli's","String.blit");
      ( "con's","String.concat");
      ( "low's","String.lowercase");
      ( "upp's","String.uppercase");
      ( "cap's","String.capitalize");
      ( "unc's","String.uncapitalize");
(* Char *)
      ( "upp'c","Char.uppercase");
      ( "low'c","Char.lowercase");
(* Mutex *)
      ( "loc'm","Mutex.lock");
      ( "unl'm","Mutex.unlock");
      ( "cre'm","Mutex.create");
      ( "cre'c","Condition.create");
      ( "wai'c","Condition.wait");
      ( "cre't","Thread.create");
      ( "len'w","Weak.length");
      ( "set'w","Weak.set");
      ( "get'w","Weak.get");
      ( "a'","Array");
      ( "c'","Char");
      ( "d'","Digest");
      ( "f'","Filename");
      ( "h'","Hashtbl");
      ( "l'","List");
      ( "m'","Map");
      ( "o'","Obj");
      ( "p'","Printexc");
      ( "q'","Queue");
      ( "r'","Random");
      ( "s'","String");
      ( "t'","Thread");
      ( "w'","Weak");
    ]
    

(**********************  indentations *******************)
  
let start_regexp = define_option ["ocaml_mode"; "start_regexp"]
    "" regexp_option (
    string_to_regex "^\(let\|module\|type\|exception\|open\)");;

type indentations = (int * (Text.position list)) list
let indentation = define_option ["ocaml_mode"; "indentation"] ""
  int_option 2
  
let print_indentations list =
  print_string "Indentations :"; print_newline ();
  List.iter (fun (indent, list) ->
      List.iter (fun pos -> 
          Printf.printf "Line at %d with %d" pos indent
      ) list
  ) list;
  print_newline ()

let print_stack stack =
  print_string "Indentation stack:"; print_newline ();
  let rec iter stack =
    match stack with
      [] -> ()
    | (token, indent) :: stack ->
        Printf.printf "Token %s indent %d" 
          (List.assoc token tokens) indent;
        print_newline ();
        iter stack
  in
  iter stack

let rec pop_to_top stack =
  match stack with
    [] -> ([],0)
  | (STRUCT,indent) :: _ -> stack, indent+ !!indentation
  | (SIG,indent) :: _ -> stack, indent+ !!indentation
  | (LBRACE,indent) :: _ -> stack, indent+ !!indentation
  | (OBJECT,indent) :: _ -> stack, indent+ !!indentation
  | _ :: stack -> pop_to_top stack

let rec pop_to kwd stack =
  match stack with
    [] -> ([],0)
  | (kwd',indent) :: stack when kwd' = kwd -> stack, indent
  | _ :: stack -> pop_to kwd stack

let rec pop_to_kwds kwds stack =
  match stack with
    [] -> ([],SEMISEMI, 0)
  | (kwd,indent) :: stack when List.memq kwd kwds -> 
      stack, kwd, indent
  | _ :: stack -> pop_to_kwds kwds stack

let fix indent eols indents =
  match eols with
    [] -> indents
  | _ -> 
      match indents with
        (pindent,peols) :: tail when pindent = indent ->
          (indent, eols @ peols) :: tail
      | _ ->  (indent,eols) :: indents

let rec pop_indentation indents =
  match indents with
    [] -> raise Not_found
  | (indent, eols) :: indents ->
      match eols with
        [] -> pop_indentation indents
      | eol :: eols ->
          (indent, eol, (indent,eols) :: indents)

let token_offset prev_tok =
  match prev_tok with
  
  | CHAR | GREATERRBRACE | GREATERRBRACKET | FALSE | FLOAT | INFIXOP0
  | INFIXOP1 | INFIXOP2 | INFIXOP3 | INFIXOP4 | INT | LESS | LESSMINUS
  | LIDENT | DONE | END | BARRBRACKET | UIDENT | UNDERSCORE | STRING 
  | PREFIXOP | QUESTION | QUOTE | RBRACE  | RBRACKET | RULE | PARSE
    ->  !!indentation
  
  | AMPERAMPER | AMPERSAND | AND | AS | ASSERT | BAR | BARBAR | BEGIN
  | CLASS | COLON | COLONCOLON | COLONEQUAL | COLONGREATER | COMMA 
  |   CONSTRAINT | DO | DOT | DOTDOT | DOWNTO | ELSE | EQUAL | EXCEPTION 
  | EXTERNAL | FOR | FUN | FUNCTION | FUNCTOR | GREATER | IF | IN 
  | INCLUDE | INHERIT | INITIALIZER | LAZY | LBRACE | LBRACELESS 
  | LBRACKET | LBRACKETBAR | LBRACKETLESS | LET | LPAREN | MATCH 
  | METHOD | MINUSGREATER | MODULE | MUTABLE | NEW | OBJECT | OF | OPEN
  | OR | PARSER | PRIVATE
  | REC | RPAREN | SEMI | SEMISEMI
  | SHARP | SIG | STAR | STRUCT | SUBTRACTIVE | THEN | TO | TRUE | TRY
  | TYPE | VAL | VIRTUAL | WHEN | WHILE | WITH
    -> 0
  
  | _ -> 0

let rec parse lexbuf prev_tok stack eols indent indents =
  let _, token = token lexbuf in
  match token with
    EOL pos -> parse lexbuf prev_tok stack (pos::eols) indent indents
  | EOF pos -> fix indent  (pos :: eols) indents
  | EOFSTRING -> (0,[0]) :: (fix indent eols indents)
  | EOFCOMMENT -> ( !!indentation,[0]) :: (fix 0 eols indents)
  | COMMENT -> parse lexbuf prev_tok stack [] indent (fix 0 eols indents)
  | LET ->
      (* 
  indentation des LETs: Il faut savoir s'il s'agit d'un LET avec ou sans IN.
   Pour cela, on regarde simplement le token precedent.
   Voici ceux qui ne peuvent pas introduire un TOP-LET
*)
      begin
        match prev_tok with
          IN | THEN | COLONCOLON | INFIXOP0 | INFIXOP0 | INFIXOP1 |
          INFIXOP2 | INFIXOP3 | INFIXOP4 | SUBTRACTIVE | STAR | EQUAL | LESS |
          GREATER | OR | BARBAR | AMPERAMPER | AMPERSAND | COLONEQUAL |
          LESSMINUS | LPAREN | LBRACKET | LBRACKETBAR | MATCH | TRY | IF |
          WHILE | DO | TO | DOWNTO | BEGIN | MINUSGREATER | WHEN | COMMA |
          SEMI | QUESTION | QUOTE | BAR ->
            (* On reste dans le bloc precedent, donc avec la meme indentation *)
            parse lexbuf token ((token,indent) :: stack) [] (indent+ !!indentation) 
            (fix indent eols indents)
        
        | ELSE ->
            (* On reste dans le bloc precedent, mais avec une indentation plus
        petite car on est sorti du IF THEN ELSE *)
            parse lexbuf token ((token,indent- !!indentation) :: stack) [] indent 
              (fix (indent- !!indentation) eols indents)
        
        | _ ->
            (* On est dans un nouveau LET toplevel *)
            let (stack, indent) = pop_to_top stack in
            parse lexbuf token ((token,indent) :: stack) [] (indent+ !!indentation) 
            (fix indent eols indents)
      
      end
  
  | VAL | EXTERNAL | TYPE | EXCEPTION | OPEN
  | INCLUDE | CLASS | RULE | METHOD | INITIALIZER | VIRTUAL ->
      (* On est dans une pharse toplevel *)
      let (stack, indent) = pop_to_top stack in
      parse lexbuf token ((token,indent) :: stack) [] (indent+ !!indentation) 
      (fix indent eols indents)
  
  | SEMISEMI ->
      let (stack,indent) = pop_to_top stack in
      parse lexbuf token stack [] indent (fix indent eols indents)
  
  | MODULE ->
      if prev_tok = LET then
        (* LET MODULE *) 
        parse lexbuf token stack [] indent (fix indent eols indents)
      else
        (* On est dans une pharse toplevel *)
      let (stack, indent) = pop_to_top stack in
      parse lexbuf token ((token,indent) :: stack) [] (indent+ !!indentation) 
      (fix indent eols indents)
  
  | EQUAL ->
      let (stack',kwd,indent') = pop_to_kwds [DEF; BAR] stack in
      (* if we find a DEF, we are the first = after the DEF, ie a process
      follows. We put a BAR to prevent any other EQUAL to match this DEF.
  Other EQUALs should not be affected by this JoCaml need. *)
      
      if kwd = DEF then
        parse lexbuf token 
          ((BAR,indent)::stack) [] indent (fix indent eols indents)
      else
        parse lexbuf token stack [] indent (fix indent eols indents)
  
  | AND ->
      let (stack,kwd,indent) = pop_to_kwds 
          [LET;TYPE;RULE;CLASS;DEF;LOC] stack in
      parse lexbuf token ((kwd,indent)::stack)
      [] (indent+ !!indentation) (fix indent eols indents) 
  | OR ->
      let (stack',kwd,indent') = pop_to_kwds  [DEF] stack in
      if kwd = DEF then
        parse lexbuf token stack
          [] (indent'+ !!indentation) (fix indent' eols indents)
      else
        parse lexbuf token stack
          [] indent (fix indent eols indents)
  
  | IN -> 
      (* partially terminate a LET structure *)
      let (stack,indent) = pop_to LET stack in
      parse lexbuf token ((IN,indent)::stack)
      [] indent (fix indent eols indents)
  
  | DEF
  | LOC -> 
      parse lexbuf token ((token,indent)::stack)
      [] (indent+ !!indentation) (fix indent eols indents)
  
  | DO ->
(* starts a DO ... DONE structure *)
      let (stack',kwd,indent') = pop_to_kwds [WHILE;FOR;LOC] stack in
      if kwd = LOC then
      (* LOC ... DO { ... } *)
        parse lexbuf DO stack [] (indent'+ !!indentation) 
        (fix indent' eols indents)
      else
        parse lexbuf DO ((DO,indent') :: stack') [] (indent'+ !!indentation) 
        (fix indent' eols indents)
(* These keywords start multi-keywords block structures. *)

(* This symbol has different meanings in lexer files *)
  | LBRACE          (* LBRACE ... RBRACE *)
    ->
      if prev_tok = RBRACE &&
        (match stack with
            (BAR,_) :: _ 
          | (PARSE,_) :: _
            -> true
          | _ -> false) then
        parse lexbuf SEMISEMI [] [] 0 
          (fix 0 eols indents)
      else
      let offset = token_offset prev_tok in
      parse lexbuf token ((token,indent) :: stack) [] (indent+ !!indentation) 
      (fix (indent+offset) eols indents)

(* Terminated structures *)
  | LPAREN          (* LPAREN ... RPAREN *)
  | LBRACELESS      (* LBRACELESS ... GREATERRBRACE  *)
  | LBRACKET        (* LBRACKET ... RBRACKET  *)
  | LBRACKETBAR     (* LBRACKETBAR ... BARRBRACKET *)
  | LBRACKETLESS    (* LBRACKETLESS ... GREATERRBRACKET *)
  | BEGIN           (* BEGIN ... END  *)
    ->
      let offset = token_offset prev_tok in
      parse lexbuf token ((token,indent) :: stack) [] (indent+ !!indentation) 
      (fix (indent+offset) eols indents)
      | COLON
    ->
      let offset = token_offset prev_tok in
      parse lexbuf token ((token,indent) :: stack) [] indent
        (fix (indent+offset) eols indents)
  
  | STRUCT          (* STRUCT ... END *)
  | SIG             (* SIG ... END *)
  | FOR             (* FOR ... TO/DOWNTO... DO  ... DONE  *)
  | WHILE           (* WHILE ... DO ... DONE  *)
  | OBJECT
    
(* Non-terminated structures *)
  | MATCH           (*  MATCH ... WITH ...  *)
  | TRY             (*  TRY ... WITH ...  *)
  | FUNCTION        (*  FUNCTION ... MINUSGREATER ...  *)
  | FUN             (*  FUN ... MINUSGREATER ...  *)
  | PARSER          (*  PARSER ... MINUSGREATER ...  *)
  | IF              (*  TRY ... WITH ...  *)
    ->
      begin
        match prev_tok with
          ELSE ->
            (* On reste dans le bloc precedent, mais avec une indentation plus
            petite car on est sorti du IF THEN ELSE *)
            parse lexbuf token ((token,indent- !!indentation) :: stack) [] indent 
              (fix (indent- !!indentation) eols indents)
        
        | _ ->
            parse lexbuf token ((token,indent) :: stack) [] (indent+ !!indentation) 
            (fix indent eols indents)
      end
      
(* Deterministic Terminators *) 
  | RPAREN 
  | RBRACE
  | GREATERRBRACE 
  | RBRACKET 
  | BARRBRACKET 
  | GREATERRBRACKET ->
      (* find corresponding block delimiter *)
      let kwd = List.assoc token 
          [
          RPAREN, LPAREN;
          RBRACE, LBRACE;
          RBRACKET,LBRACKET;
          BARRBRACKET, LBRACKETBAR;
          GREATERRBRACE, LBRACELESS;
          GREATERRBRACKET, LBRACKETLESS
        ]
      in
      let (stack,indent) = pop_to kwd stack in
      parse lexbuf token stack [] indent (fix indent eols indents)
      (* Non-deterministic terminators *)
  | END 
  | DONE
    ->
      let kwds = List.assoc token 
          [
          END,[BEGIN;STRUCT;SIG];
          DONE, [FOR;WHILE;DO;TO;DOWNTO]
        ] 
      in
      let (stack,kwd, indent) = pop_to_kwds kwds stack in
      parse lexbuf token stack [] indent (fix indent eols indents)
  | WITH ->
      let (stack,kwd,indent) = pop_to_kwds [MATCH;TRY;LBRACE] stack in
      if kwd = LBRACE then
        parse lexbuf token ((LBRACE,indent)::stack) [] (indent+ !!indentation)
        (fix indent eols indents)        
      else
        parse lexbuf token ((WITH,indent)::stack) [] (indent+ !!indentation)
        (fix indent eols indents)
  | BAR ->
      let (stack,kwd,indent) = 
        pop_to_kwds [WITH;FUNCTION;BAR;TYPE;PARSE;LPAREN;LBRACE;DEF] stack in
      let kwd = 
        match kwd with
          TYPE | LPAREN | PARSE | LBRACE | DEF -> kwd
        | _ -> BAR
      in
      parse lexbuf token ((kwd,indent)::stack) [] (indent+ !!indentation)
      (fix indent eols indents)
  | MINUSGREATER ->
      let (stack,kwd,indent) =
        pop_to_kwds [WITH;FUN;BAR;FUNCTION;TYPE;LPAREN;EXTERNAL;VAL;COLON] stack in
      begin
        match kwd with
          TYPE | LPAREN | EXTERNAL | VAL | COLON ->
            let offset = token_offset prev_tok in
            parse lexbuf token ((kwd,indent)::stack) [] indent 
              (fix (indent+offset) eols indents)
        | _ ->
            parse lexbuf token ((BAR,indent)::stack) [] 
              (if kwd = FUN then indent+ !!indentation else indent+ 2 * !!indentation)
            (fix (indent+ !!indentation) eols indents) 
      end
  | THEN ->
      let (stack,indent) = pop_to IF stack in
      parse lexbuf token ((THEN,indent)::stack) [] (indent+ !!indentation)
      (fix indent eols indents) 
  | ELSE ->
      let (stack,indent) = pop_to THEN stack in
      parse lexbuf token ((ELSE,indent)::stack) [] (indent+ !!indentation)
      (fix indent eols indents) 
  | SEMI ->
      let old_stack = stack in
(* le ; termine un THEN ... ou ELSE ... s'il n'y a pas 
   construction infinie (LET, IN, MATCH, BAR) avant *)
      let (stack1,_,indent1) = pop_to_kwds [THEN;ELSE] stack in
      let (stack2,_,_) = pop_to_kwds
          [
          LET; IN; COLONCOLON; INFIXOP0; INFIXOP0; INFIXOP1; INFIXOP2;
          INFIXOP3; INFIXOP4; SUBTRACTIVE; STAR; EQUAL; LESS; GREATER;
          OR; BARBAR; AMPERAMPER; AMPERSAND; COLONEQUAL; LESSMINUS;
          LPAREN; LBRACKET; LBRACKETBAR; MATCH; TRY; IF; WHILE; DO; TO;
          DOWNTO; BEGIN; MINUSGREATER; WHEN; COMMA; SEMI; QUESTION;
          QUOTE; BAR; LBRACE
        ]
          stack in
      let new_stack, new_indent =
        if List.length stack1 > List.length stack2 then 
(* le THEN ou ELSE est en premier *)
          stack1, indent1
        else
        (* on continue tout simplement *)
          stack, indent
      in
      parse lexbuf token new_stack [] new_indent
        (fix indent eols indents)
  
  | PARSE           (* RULE ... PARSE ... *)
    ->
      begin
        match stack with
          (RULE,_) :: _ ->
            parse lexbuf token ((token,indent) :: stack) [] indent 
              (fix indent eols indents)
        | _ ->
            let offset = token_offset prev_tok in
            parse lexbuf token stack [] indent 
              (fix (indent+offset) eols indents)
      end
  | _ ->
      
      let offset = token_offset prev_tok in
      parse lexbuf token stack [] indent 
        (fix (indent+offset) eols indents)

let get_indentations pos lexbuf =
  parse lexbuf SEMISEMI [] [] 0 []

let print_exc e s =
  Printf.printf "Caught exception %s in %s" (Printexc.to_string e) s;
  print_newline ()

(* Now, use the indentation from the parser *)

let compute_indentations buf start_point end_point =
  let text = buf.buf_text in
  let curseur = Text.dup_point text start_point in
(* init indentation *)
  let pos = get_position text end_point in
  let lexbuf = lexing text curseur end_point in
  try
    let indentations = 
      get_indentations (get_position text start_point) lexbuf in
    remove_point text curseur;
    indentations
  with
    e ->
      remove_point text curseur;
      raise e

let find_phrase_start buf curseur =
  let text = buf.buf_text in
  try
    let _ = Text.search_backward text (snd !!start_regexp) curseur in ()
  with
    Not_found -> Text.set_position text curseur 0

let indent_between_points buf start_point end_point =
  let text = buf.buf_text in
  let session = start_session text in
  let curseur = dup_point text start_point in
  try
    find_phrase_start buf curseur;
    let indentations = compute_indentations buf curseur end_point in
(* remove the Eof indentation *)
    let _,_,indentations = pop_indentation indentations in
(* indent other lines *)
    let rec iter indents =
      let (current,pos,indents) = pop_indentation indents in
      set_position text curseur (pos+1);
      set_indent text curseur current;
      iter indents
    in
    iter indentations
  with
    e -> 
      commit_session text session;
      remove_point text curseur

(* Interactive: indent all lines of the current block *)
let indent_phrase frame =
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  indent_between_points buf point point

let indent_region frame =
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  let (start_point,end_point) =
    if point < mark then (point,mark) else (mark,point) 
  in
  indent_between_points buf start_point end_point


let indent_buffer frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let start_point = add_point text in
  let end_point = add_point text in
  set_position text end_point (Text.size text);
  indent_between_points buf start_point end_point;
  remove_point text start_point;
  remove_point text end_point

(* Interactive: indent the current line, insert newline and indent next line *)
let insert_and_return frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
(* colors *)
  let start_point = dup_point text point in
  bmove text start_point (point_to_bol text start_point);
  ocaml_color_region buf.buf_location buf start_point point;
  remove_point text start_point;
(* indentations *)
  let curseur = dup_point text point in
  try
    find_phrase_start buf curseur;
    let indentations = compute_indentations buf curseur point in
    remove_point text curseur;
    let (next,pos,tail) = pop_indentation indentations in
    let current =
      try
        let (current, _, _ ) = pop_indentation tail in current
      with
        Not_found  -> 0
    in
    let session = start_session text in
    set_indent text point current;
    insert_char frame '\n';
    set_indent text point next;
    commit_session text session;
    fmove text point next; 
    ()
  with
    e -> 
      remove_point text curseur;
      insert_char frame '\n'

(* Interactive: indent the current line, insert newline and indent next line *)
let indent_current_line frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
(* colors *)
  let end_point = dup_point text point in
  let start_point = dup_point text point in
  bmove text start_point (point_to_bol text start_point);
  fmove text end_point (point_to_eol text end_point);
  ocaml_color_region buf.buf_location buf start_point end_point;
  remove_point text start_point;
  remove_point text end_point;
(* indentations *)
  let curseur = dup_point text point in
  find_phrase_start buf curseur;
  let indentations = compute_indentations buf curseur point in
  remove_point text curseur;
  let (next,pos,tail) = pop_indentation indentations in
  let current =
    try
      let (current, _, _ ) = pop_indentation tail in current
    with
      Not_found  -> 0
  in
  set_indent text point current

(*********************  aide a la programmation *********)

  (* split a string (remove chr) *)
let split1 str chr =
  let list = ref [] in
  let start = ref 0 in
  for i = 0 to String.length str - 1 do
    if str.[i] = chr then
      let s = String.sub str !start (i - !start) in
      if s <> "" then list := s :: !list;
      start := i+1
  done;
  let s = String.sub str !start (String.length str - !start) in
  if s <> "" then list := s :: !list;
  List.rev !list


let parse_name str = split1 str '.'

(* open a minibuffer for a long name (module+name), then look
 in the corresponding .cmi file to find the type of the value *)



let find_long_word buf point =
  buf.buf_syntax_table.(Char.code '.') <- true;
  let w = current_word buf point in
  buf.buf_syntax_table.(Char.code '.') <- false;
  w  
  
  (*
  A rudimentary parser, to find all OPEN directives. This will be
  useful when trying to discover where a name is defined.
  In particular, we will open each .cmi file to find the name.
  *)

let module_name buf_name = 
  Filename.chop_extension (String.capitalize buf_name)

let find_env buf point =
  let text = buf.buf_text in
  let tmp_point = add_point text in
  let rec parse lexbuf stack env =
    let _, t = token lexbuf in
    match t with
      STRUCT -> parse lexbuf ((STRUCT,env) :: stack) env
    | OPEN -> 
        let (pos,len),t = token lexbuf in
        if t <> UIDENT then
          parse lexbuf stack env
        else
          (set_position text tmp_point pos; 
            let ident = Text.sub text tmp_point len in
            parse lexbuf stack (ident::env))
    | END ->
        let stack,env = 
          match stack with
            (STRUCT,env) :: tail -> tail, env
          | _ :: tail -> tail, env
          | [] -> [], env
        in
        parse lexbuf stack env
    | EOFSTRING 
    | EOFCOMMENT
    | EOF _ -> env
    | _ -> parse lexbuf stack env
  in
  let end_point = dup_point text point in
  let curseur = add_point text in
  let lexbuf = lexing text curseur end_point in
  let env = parse lexbuf [] [] in
  remove_point text curseur;
  remove_point text tmp_point;
  remove_point text end_point;
  (module_name buf.buf_name) :: env

(* C-f1 : approximatively parse the file to find the implementation for
the word under the cursor. During parsing, an envirronment is built and
then used to find the word. 
*)

let ocaml_error_regexp = define_option ["ocaml_mode"; "error_regexp"] ""
    regexp_option (string_to_regex
    "File \"\\(.*\\)\", line \\([0-9]+\\), characters \\([0-9]+\\)[-]\\([0-9]*\\):")
  
let ocaml_find_error text error_point =
  let groups = 
    Text.search_forward_groups text (snd !!ocaml_error_regexp) 
      error_point 4 in
  let error =
    {  
      err_msg = Text.get_position text error_point;
      err_filename = groups.(0);
      err_line = (int_of_string groups.(1)) - 1;
      err_begin = int_of_string groups.(2);
      err_end = try
        int_of_string groups.(3)
      with
        _ -> int_of_string groups.(2)
    } in
  Text.fmove text error_point 1;
  error

  (*********************  structures ********************)
let c_c = (ControlMap,Char.code 'c')

let structures = define_option ["ocaml_mode"; "structures"] ""
    (list_option binding_option) []
  
let _ = 
  if !!structures = [] then
    let n' = NormalMap,Char.code '\'' in
    structures =:=
    [
      [c_c; n'; NormalMap, Char.code 'b'], "begin ^^ end^^";
      [c_c; n'; NormalMap, Char.code 'f'], "for ^^ to ^^ do\n^^";
      [c_c; n'; NormalMap, Char.code 'w'], "while ^^ do\n^^\ndone";
      [c_c; n'; NormalMap, Char.code 't'], "try\n ^^ \nwith\n ^^";
      [c_c; n'; NormalMap, Char.code 'm'], "match ^^ with\n ^^";
      [c_c; n'; NormalMap, Char.code 'i'], "if ^^ then\n ^^\n else\n ^^";
      [c_c; n'; NormalMap, Char.code 'l'], "let ^^ = ^^ in\n ^^";
    ]    
  
(*********************  installation ********************)

let syntax = define_option ["ocaml_mode"; "syntax"] 
    "Chars which should not are part of idents" 
    string_option "_\'"
  
  
let ocaml_hooks = define_option ["ocaml_mode"; "hooks"] "" 
  (list_option string_option)
  [  "paren_mode" ]
  
let install buf =
  ocaml_color_buffer buf; 
  let syntax = !!syntax in
  for i = 0 to String.length syntax - 1 do
    buf.buf_syntax_table.(Char.code syntax.[i]) <- true;
  done;
  let abbrevs = Hashtbl.create 11 in
  set_local buf abbrev_table abbrevs;
  Utils.hash_add_assoc abbrevs !!abbreviations;
  install_structures buf !!structures;
    List.iter (fun action ->
      try execute_buffer_action action buf with _ -> ()
  ) !!ocaml_hooks;
  ()

  
let mode =  Ebuffer.new_major_mode "Ocaml" [install]
let map = mode.maj_map

let ocaml_mode frame = Ebuffer.set_major_mode frame.frm_buffer mode
        
let _ = 
  define_action "ocaml_mode" ocaml_mode;
  define_action "ocaml_mode.compile" (compile ocaml_find_error);
  define_action "ocaml_mode.color_buffer" 
    (fun frame -> ocaml_color_buffer frame.frm_buffer);
  define_action "ocaml_mode.indent_buffer" indent_buffer;
  define_action "ocaml_mode.eval_buffer" eval_buffer;
  define_action "ocaml_mode.indent_phrase" indent_phrase;
  define_action "ocaml_mode.indent_line" indent_current_line;
  define_action "ocaml_mode.char_expand_abbrev" (fun frame ->
      expand_sabbrev frame; self_insert_command frame);
  define_action "ocaml_mode.return_expand_abbrev"
    (fun frame -> expand_sabbrev frame; insert_and_return frame); 
  ()
  
let local_map = define_option ["ocaml_mode"; "local_map"] ""
    (list_option binding_option) []

let interactives_map = define_option ["ocaml_mode"; "interactives_map"] ""
    (list_option string2_option) 
  []

let _ =
  if !!local_map = [] then
    local_map =:= [
      [c_c; ControlMap, Char.code 'c'], "ocaml_mode.compile";    
      [ControlMap, Char.code 'l'], "ocaml_mode.color_buffer";
      [c_c; ControlMap, Char.code 'b'], "ocaml_mode.indent_buffer";
      [c_c; ControlMap, Char.code 'C'], "ocaml_mode.color_buffer";
      [c_c; ControlMap,Char.code 'e'], "ocaml_mode.eval_buffer";
      [c_c; ControlMap,Char.code 'l'], "ocaml_mode.color_buffer";
      [MetaMap,Char.code 'q'], "ocaml_mode.indent_phrase";
      [NormalMap,XK.xk_Tab], "ocaml_mode.indent_line";
      [NormalMap, Char.code '.'], "ocaml_mode.char_expand_abbrev";
      [NormalMap, Char.code ';'], "ocaml_mode.char_expand_abbrev";
      [NormalMap, XK.xk_Return], "ocaml_mode.return_expand_abbrev";

    ];
  if !!interactives_map = [] then 
        interactives_map =:= [
          "compile", "ocaml_mode.compile";
          "color_buffer", "ocaml_mode.color_buffer";
      ]

let _ =
  let map = mode.maj_map in
  List.iter (fun (keys, action) ->
      try
        let f = execute_action action in
        Keymap.add_binding map keys f;
        add_interactive map action f;
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  
  ) !!local_map;
  List.iter (fun (name, action) ->
      try
        add_interactive map name (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;          
  ) !!interactives_map;

  ()

let mode_regexp = define_option ["ocaml_mode"; "mode_regexp"] ""
    (list_option string_option) [".*\.\(ml\|mli\|mll\|mly\|mlp\|mlg\)"]
  
let _ =  
  Efuns.add_start_hook (fun location ->
      let alist = get_global location Ebuffer.modes_alist in
      set_global location Ebuffer.modes_alist 
        ((List.map (fun s -> s,mode) !!mode_regexp) @ alist);
      add_option_parameter location keyword_color;
      add_option_parameter location string_color;
      add_option_parameter location comment_color;
      add_option_parameter location upper_color;
      add_option_parameter location keyword_font;
      add_option_parameter location string_font;
      add_option_parameter location comment_font;
      add_option_parameter location upper_font;
      add_option_parameter location ocaml_path;
      add_option_parameter location indentation;
  )  
  (*** Ocaml minor mode (for Makefiles (!)) ***)

let minor_mode = Ebuffer.new_minor_mode "ocaml" []
  
let _ =
  ignore (Keymap.add_binding minor_mode.min_map 
      [c_c; ControlMap, Char.code 'c'] (execute_action "ocaml_mode.compile"))
  ;
  
  define_action "ocaml_minor_mode" 
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf minor_mode then begin
          Ebuffer.del_minor_mode buf minor_mode
        end else
        Ebuffer.set_minor_mode buf minor_mode)


# 2292 "ocaml_mode.ml"
